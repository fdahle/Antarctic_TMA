"""Adapt the masks generated by Agisoft Metashape"""

import Metashape
import numpy as np
import os

from tqdm import tqdm

import src.base.resize_image as ri
import src.export.export_tiff as et
import src.load.load_image as li
import src.sfm_agi2.snippets.create_db_mask as cam

def union_masks(chunk: Metashape.Chunk,
                agi_mask_folder: str,
                custom_mask_folder: str,
                adapted_mask_folder: str,
                use_database: bool = False,
                adapt_custom_masks: bool = False,
                tolerance_value: int = 0) -> None:

    # create folder for adapted masks
    os.makedirs(adapted_mask_folder, exist_ok=True)

    # init conn variable
    conn = None

    pbar = tqdm(total=len(chunk.cameras), desc="Union masks",
                position=0, leave=True)

    # iterate all cameras
    for camera in chunk.cameras:

        # update progress bar description
        pbar.set_postfix_str(camera.label)

        # get the camera name
        image_id = camera.label

        # load all masks
        agi_mask = li.load_image(os.path.join(agi_mask_folder, image_id + ".tif"), catch=True)
        custom_mask = li.load_image(os.path.join(custom_mask_folder, image_id + ".tif"), catch=True)

        if (agi_mask is not None and custom_mask is not None and
                agi_mask.shape != custom_mask.shape):

            #  check the difference in shape
            diff_x = abs(agi_mask.shape[1] - custom_mask.shape[1])
            diff_y = abs(agi_mask.shape[0] - custom_mask.shape[0])

            if (adapt_custom_masks and
                    diff_x <= tolerance_value and diff_y <= tolerance_value):
                custom_mask = ri.resize_image(custom_mask, agi_mask.shape)
            else:
                raise ValueError(f"Mask shapes do not match for {image_id}: "
                                 f"{agi_mask.shape} != {custom_mask.shape}")

        # fill missing masks with ones
        if agi_mask is None:
            agi_mask = np.ones_like(custom_mask, dtype=np.bool_)
        elif custom_mask is None:
            custom_mask = np.ones_like(agi_mask, dtype=np.bool_)

        # create a mask based on db entries
        if use_database:
            db_mask, conn = cam.create_db_mask(agi_mask.shape, camera.label, conn)
        else:
            db_mask = np.ones(agi_mask.shape)

        # join all masks
        adapted_mask = np.logical_and(agi_mask, custom_mask)
        adapted_mask = np.logical_and(adapted_mask, db_mask)

        # cast to uint8
        adapted_mask = adapted_mask.astype(np.uint8) * 255

        # create path for the adapted mask
        pth_adapted_mask = os.path.join(adapted_mask_folder, camera.label + '.tif')

        # export the adapted mask to the adapted mask folder
        et.export_tiff(adapted_mask, pth_adapted_mask,
                       use_lzw=True)

        # convert adapted mask to Metashape image
        adapted_mask_m = Metashape.Image.fromstring(adapted_mask,
                                         adapted_mask.shape[1],
                                         adapted_mask.shape[0],
                                         channels=' ', # noqa
                                         datatype='U8')

        # create a mask object
        mask_obj = Metashape.Mask()
        mask_obj.setImage(adapted_mask_m)

        # set the mask to the camera
        camera.mask = mask_obj

        # update progres bar
        pbar.update(1)

    # close progress bar
    pbar.set_postfix_str("- Finished -")
    pbar.close()


    return